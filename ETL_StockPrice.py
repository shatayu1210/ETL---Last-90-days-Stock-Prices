# -*- coding: utf-8 -*-
"""Homework5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1txrcVhkYGIsPRbySvStCTioVMwk07F-Z
"""

# Importing necessary modules
from airflow import DAG
from airflow.models import Variable
from airflow.decorators import task
from airflow.providers.snowflake.hooks.snowflake import SnowflakeHook

import snowflake.connector
import requests
from datetime import datetime, timedelta

# Establishing connection to Snowflake
def return_snowflake_conn():
    hook = SnowflakeHook(snowflake_conn_id='snowflake_conn') # Initialize the SnowflakeHook
    conn = hook.get_conn()
    return conn.cursor() # Created a cursor object to work with databases


# Creating Function to read stock prices based on symbol provided
@task
def extract_stock_data(symbol):
    vantage_api_key = Variable.get("vantage_api_key")
    url = f"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={vantage_api_key}"
    r = requests.get(url)
    data = (r.json())  # Storing all data for given symbol in json form, fetched from alpha vantage api
    results = []  # Initializing empty list
    for d in data["Time Series (Daily)"]:  # Here the keys under 'Time Series (Daily)' are stored, which are the dates
        stock_info = data["Time Series (Daily)"][d]  # This stores the stock prices info for each iterated date
        stock_info["date"] = d  # Creating another key value pair for date to the end of stock_info dictionary
        results.append(stock_info)  # Each stock_info instance of dictionary that holds the stock prices along with that particular date is added to results list
    return results


# Transforming stock data to return only 90d data
@task
def transform_to_90d_stock_data(results):
    today = datetime.now().date()  # Get today's date
    ninety_days_ago = today - timedelta(days=90)  # Calculate the date 90 days ago

    # Filter results for the last 90 days
    filtered_results = [
        entry
        for entry in results
        if datetime.strptime(entry["date"], "%Y-%m-%d").date() >= ninety_days_ago
    ]
    return filtered_results


# Loading last 90d data into snowflake table
@task
def load_stock_data(table, results, symbol):
    # Define Query for Table Create or Replace by using table parameter passed to this function
    table_create = f"""
  CREATE OR REPLACE TABLE {table} (
      date DATE,
      open FLOAT,
      high FLOAT,
      low FLOAT,
      close FLOAT,
      volume INT,
      symbol STRING
  );
  """

    try:
        cursor = (return_snowflake_conn())  # Created cursor object to execute snowflake operations
        cursor.execute("BEGIN;")  # Starting a transaction
        cursor.execute(table_create)  # Create a new table with required fields if not existing, else replace
        print("Table Ready on Snowflake!")  # Acknowledging

        index = 1  # Initialize variable to keep count of inserts executed
        print(
            "Number of Records to be inserted:", len(results)
        )  # Displaying length of results to be matched against each iterated index

        for (r) in (results):  # Loading records to snowflake table through insert query for each record from results
            open = r["1. open"]
            high = r["2. high"]
            low = r["3. low"]
            close = r["4. close"]
            volume = r["5. volume"]
            date = r["date"]

            # Using MERGE to handle existing records
            merge_sql = f"""
            MERGE INTO {table} AS target
            USING (SELECT '{date}' AS date, '{open}' AS open, '{high}' AS high, '{low}' AS low, '{close}' AS close, '{volume}' AS volume, '{symbol}' AS symbol) AS source
            ON target.symbol = source.symbol and target.date = source.date
            WHEN MATCHED THEN
                UPDATE SET
                    date = source.date,
                    open = source.open,
                    high = source.high,
                    low = source.low,
                    close = source.close,
                    volume = source.volume
            WHEN NOT MATCHED THEN
                INSERT (date, open, high, low, close, volume, symbol)
                VALUES (source.date, source.open, source.high, source.low, source.close, source.volume, source.symbol);
            """
            print("Executing: ", merge_sql)
            cursor.execute(merge_sql)
            print("Number of Inserts Executed: ", index)
            index += 1
        cursor.execute("COMMIT;")
    except Exception as e:  # Roll back entire operation in case of errors during load
        cursor.execute("ROLLBACK;")
        print(f"An error occurred: {e}")


with DAG(
    dag_id="Load_90d_Apple_Stock",
    default_args={
        "owner": "Shatayu Thakur",
        "email": ["shatayu.thakur@sjsu.edu"],
        "email_on_failure": True,
        "email_on_retry": True,
        "email_on_success": True,
        "retries": 1,
        "retry_delay": timedelta(minutes=5),
    },
    start_date=datetime(2024, 9, 28),
    catchup=False,
    tags=["ETL"],
    schedule="30 12 * * *",
) as dag:
    target_table = "dev.raw_data.stock_data"
    symbol = "AAPL"

    data = extract_stock_data(symbol)  # Extracting stock price data for Apple
    transformed_data = transform_to_90d_stock_data(data)  # Transforming stock price records to include data from last 90d
    load_stock_data(target_table, transformed_data, symbol)  # Loading the extracted Apple stock price data to specified Snowflake Table